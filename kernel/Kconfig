#
# Firmware Features
#

menu "Feature setup"

menu "Generic kernel features"

choice
	prompt "Scheduling model"
	default SYS_IRQ

config SYS_NOIRQ
	bool "Polling IRQs in BH"
	help
	  No hardware interrupt handlers will be registered, all hardware
	  events are examined through polling.
	  This is a suitable architecture for those bootloaders that would
	  use an unsafe different interrupt vectors from the loaded
	  firmware.

config SYS_IRQ
	bool "IRQ interrupted BH"
	help
	  Hardware interrupt handlers will be registered, while some
	  hardware events will still be implemented in synchronous way.
	  This is a suitable architecture for those firmwares that would
	  expect faster process of interrupts and the firmware itself
	  does not require high resolution realtime responsiveness.

config SYS_RT
	bool "Polling periheral IRQs in BH, allowing timer IRQs"
	help
	  No hardware interrupt handlers will be registered besides the
	  GPT interrupts.  Other hardware events will be implemented
	  through polling.
	  This is a suitable architecture for those firmwares that would
	  expect critical realtime responsiveness.

config SYS_TASK
	bool "Multiple tasking with various IRQs"
	select TASK
	depends EXPERIMENTAL
	help
	  Same as "Polling states with various IRQs", but multi-tasking is
	  added instead of timer-driven state machines.
	  This architecture requires larger memory consumption but could
	  offer better software realtime responsiveness than the
	  "Polling states with various IRQs" architecture.

endchoice

config ARCH_HAS_LOVEC
	bool

config ARCH_HAS_HIVEC
	bool

config ARCH_HAS_VIC
	bool

config ARCH_HAS_IRQC
	bool

config ARCH_HAS_GPT
	bool

config ARCH_HAS_TSC
	bool

config ARCH_HAS_TSC_CONST
	bool

config ARCH_HAS_WDT
	bool

config ARCH_IS_TICKLESS
	bool

config ARCH_HAS_IDLE
	bool

config ARCH_IS_RAM_ONLY
	bool

menu "Scheduling facility (irq) support"
	depends !SYS_NOIRQ

config MAX_VECTORS
	int "Num of vectors (1~255)"
	range 1 255
	depends !CC_ISR_VECTOR && !ARCH_HAS_VIC
	default 4
	help
	  Vector handlers consumes RAM memories when ISR entries are
	  implemented by the firmware rather than the compiler.  Setting
	  maximum vector number the software currently is using can reduce
	  memory consumption.

endmenu

menu "Scheduling facility (bh) support"

config MAX_BHS
	int "Num of bottom halves (1~8)"
	range 1 8
	default 4
	help
	  State machines may register bottom halves for tasks.  Since
	  state machines can be disabled, you can also reduce number of
	  bottom halves here to save memory usage.
	  Following bottom halves may be required:
	  timer
	  bulk
	  task
	  And the followings may be deleted in the future:
	  ifd
	  keyboard
	  acr122
	  If you are not sure, say 6 here.

endmenu

menuconfig TASK
	bool "Scheduling facility (task) support"
	depends EXPERIMENTAL
	depends SYS_TASK
#	select HEAP

if TASK

config MAX_TASKS
	int "Num of schedulable tasks (1~8)"
	range 1 8
	default 4

endif

menuconfig SMP
	bool "Scheduling facility (SMP) support"

if SMP

endif

menu "Timing facility (jiffy) support"

config TICK
	bool "Enable tick device support"
	depends !ARCH_IS_TICKLESS
	depends !SYS_NOIRQ
	default y
	help
	  A "jiffies" variable will get compiled into the firmware and
	  the firmware may get interrupted by a jiffies counting tick
	  device hardware.

config TICK_PERIODIC
	bool "Enable periodic tick device support"
	depends TICK
	help
	  A platform that supports the periodic tick device is a platform
	  that owns a non IRQ maskable device interrupted per 1/HZ
	  seconds.
	  If the platform does not have a periodic tick device, a hardware
	  timestamp counter (TSC) device may be used to calibrate the
	  jiffies value.

endmenu

menu "Timing facility (delay) support"

config LPS_NO_LPS
	bool "Use constant TSC instead of calibrated loops/jiffy"
	depends ARCH_HAS_TSC_CONST && !TICK

if !LPS_NO_LPS

config LPS_64BITS
	bool "Enable 64 bit loops/jiffy support"
	select MATH_MUL64
	select MATH_DIV64

config LPS_32BITS
	bool "Enable 32 bit loops/jiffy support"
	depends !LPS_64BITS
	select MATH_MUL32
	select MATH_DIV32

config LPS_WEIGHT
	int "Initail loops/jiffy weight"
	default 8
	range 0 15 if (!LPS_32BITS && !LPS_64BITS)
	range 0 31 if LPS_32BITS
	range 0 64 if LPS_64BITS
	help
	  Correct initial LPS weight can help firmware to boot faster.
	  Incorrect initial LPS weight may result in calibrate delay
	  failure.
	  If calibrate delay always get failed on initial LPS weight 0, it
	  is suggested that the system should choose a counter with
	  greater bit width.
	  Initial LPS weight should be chosen carefully according to the
	  current running CPU frequency. 

config LPS_PRESET
	bool "Enabled preset loops/jiffy support"

config LPS_PRESET_MS
	int "Preset loops/ms value"
	depends LPS_PRESET
	range 1 65535 if !LPS_32BITS
	range 1 4294967296 if LPS_32BITS

endif

endmenu

menuconfig TIMER
	bool "Timing facility (timer) support"
	default y
	select TIMER_ONESHOT if !TICK
	select BIT_FIND_CLEAR

if TIMER

config TIMER_16BIT
	bool "Enable 16-bit timeout value"

config TIMER_ONESHOT
	bool "Enable onshot timer interrupt"
	depends !TICK

config MAX_TIMERS
	int "Num of timers (1~16)"
	range 1 16
	default 1
	help
	  State machines may register timers for delayed works.  Since
	  state machines can be disabled, you can also reduce number of
	  timers here to save memory usage.
	  Following state machines require timers:
	  usb (USB)
	  scs (IFD_PRES_POLL)
	  So if you are not sure, say 1 here.

endif

menu "Address space layout (.text) support"

config XIP
	bool "Enable eXecute In Place (XIP) support"
	depends !ARCH_IS_RAM_ONLY

config TEXT_ROM_BASE
	hex "Base offset of the .text section in the ROM"
	depends !ARCH_IS_RAM_ONLY
	default 0
	help
	  In XIP firmware, this could be used in the linker script to
	  determine the load address of the .text section.  While in
	  non-XIP firmware, this might be used to calculate the load
	  address of the variables created in the linker script.

config TEXT_RAM_BASE
	hex "Base offset of the .text section in the RAM"
	default 0
	help
	  For non-XIP firmware, an offset might be needed to avoid
	  system tables corss-over.  While in XIP firmware, this might be
	  used in the linker script to determine the load address of the
	  .data section.

config TEXT_RAM_LOAD
	bool "Load .text sections from the ROM to the RAM"
	depends !XIP
	default y
	help
	  For non-XIP firmware, programmer may have already loaded the
	  .text sections to the RAM due to their load addresses are RAM
	  addresses. For XIP firmware, no need to load .text sections.
	  In this case, sdfirm shouldn't copy .text sections to itself
	  by disabling this option.

config DATA_RAM_LOAD
	bool "Load .data sections from the ROM to the RAM"
	default y
	help
	  Programmer may have already loaded the .data sections to the RAM
	  due to their load addresses are RAM addresses, and hence there
	  should be no .data sections flashed in the ROM. In this case,
	  sdfirm shouldn't copy .data sections to itself by disabling this
	  option.

endmenu

menuconfig HEAP
	bool "Address space allocator (heap) support"
	help
	  Heap will start aligned from data/bss end.

if HEAP

choice
	prompt "Heap start address alignment"
	default HEAP_ALIGN_4

config HEAP_ALIGN_1
	bool "1"

config HEAP_ALIGN_2
	bool "2"

config HEAP_ALIGN_4
	bool "4"

endchoice

config HEAP_SIZE
	hex "Total heap allocable size"
	range 0x100 0x10000
	default 0x100

choice
	prompt "Allocator selection"
	default HEAP_DLMALLOC

config HEAP_DLMALLOC
	bool "Doug Lea malloc"

endchoice

config ALLOC_TRIM
	bool "Enable heap trim support"
	depends HEAP_DLMALLOC

config ALLOC_CHECK
	bool "Enable allocation check support"
	depends HEAP_DLMALLOC

endif

menuconfig MEM
	bool "Address space allocator (bootmem) support"
	select STRING_STRTOUL

if MEM

config MMU_MAP_MEM
	bool "Map memories"

config MEM_MAX_REGIONS
	int "Maximum region banks"
	default 3

config MEM_RESIZE
	bool "Enable resizable memory region array support"

endif

menuconfig PAGE
	bool "Address space allocator (page) support"
	select MEM

if PAGE

endif

config ARCH_HAS_MMU
	bool

config ARCH_HAS_MMU_4K
	bool

config ARCH_HAS_MMU_16K
	bool

config ARCH_HAS_MMU_64K
	bool

config ARCH_HAS_MMU_4M
	bool

config ARCH_HAS_MMU_1L
	bool

config ARCH_HAS_MMU_2L
	bool

config ARCH_HAS_MMU_3L
	bool

config ARCH_HAS_MMU_4L
	bool

config ARCH_HAS_MMU_5L
	bool

menuconfig MMU
	bool "Address space layout (paging) support"
	depends ARCH_HAS_MMU
	select MEM
	select PAGE

if MMU

choice
	prompt "Page size"

config MMU_4K_PAGE
	bool "4K size"
	depends ARCH_HAS_MMU_4K

config MMU_16K_PAGE
	bool "16K size"
	depends ARCH_HAS_MMU_16K

config MMU_64K_PAGE
	bool "64K size"
	depends ARCH_HAS_MMU_64K

config MMU_4M_PAGE
	bool "4M size"
	depends ARCH_HAS_MMU_4M

endchoice

choice
	prompt "Page table levels"

config MMU_1L_TABLE
	bool "1 level"
	depends ARCH_HAS_MMU_1L

config MMU_2L_TABLE
	bool "2 levels"
	depends ARCH_HAS_MMU_2L

config MMU_3L_TABLE
	bool "3 levels"
	depends ARCH_HAS_MMU_3L

config MMU_4L_TABLE
	bool "4 levels"
	depends ARCH_HAS_MMU_4L

config MMU_5L_TABLE
	bool "5 levels"
	depends ARCH_HAS_MMU_5L

endchoice

config MMU_PAGE_OFFSET
	bool "Enable kernel offset support"
	depends !BOOTLOADER

config MMU_IDMAP_DEVICE
	bool "Enable early device identity mapping"
	depends EXPERIMENTAL
	help
	  If there is a board specific definition of IDMAP_DEV_BASE, create
	  mappings for it in the boot page table. This is normally useful
	  for enabling very early consoles (earlier before the readiness of
	  the fixmap mechanism which requires the readiness of the early
	  memory resource allocator, so it is only useful for debugging the
	  memory resource allocator and the fixmap machanisms).
	  If unsure, say 'N'.

config MMU_DEBUG_TABLE
	bool "Debugging table entry population"
	depends CONSOLE_DEBUG

endif

menuconfig IDLE
	bool "Power management model (idle) support"
	depends on ARCH_HAS_IDLE

if IDLE

endif

menuconfig BULK
	bool "IO data flow model (bulk) support"
	select BIT_FLS16
	select BIT_FIND_CLEAR
	select TIMER

if BULK

config BULK_MAX_CHANS
	int "Number of bulk channels"
	range 1 255
	default 1

endif

menuconfig TERM
	bool "IO data flow model (term) support"

if TERM

config TERM_MAX_CONS
	int "Number of terminal consoles"
	range 1 255

config TERM_WIDTH
	int "Characters per row"
	range 8 80
	default 80

config TERM_HEIGHT
	int "Characters per column"
	range 2 24
	default 24

endif

endmenu

config ARCH_HAS_GPIO
	bool

config GPIO
	bool "General purpose Input/Output (GPIO) support"
	depends ARCH_HAS_GPIO

config ARCH_HAS_CLK
	bool

config CLK
	bool "Clock tree framework support"

if CLK

config CLK_MAX_DRIVERS
	int "Maximum clock drivers"
	range 1 10

endif

source kernel/io/Kconfig
source kernel/uart/Kconfig
source kernel/spi/Kconfig
source kernel/i2c/Kconfig
source kernel/usb/Kconfig
source kernel/scs/Kconfig
source kernel/mtd/Kconfig
source kernel/scsi/Kconfig
source kernel/net/Kconfig
source kernel/video/Kconfig

config RAS
	bool "Reliability Availability Serviceability (RAS) support"

config ARCH_HAS_PMU
	bool

config PERF
	bool "Performance counting (perf) support"
	depends ARCH_HAS_PMU

endmenu
